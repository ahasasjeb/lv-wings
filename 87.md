# 多人翅膀渲染问题修复说明

## 问题原因

在多人游戏中，虽然服务端会通过网络同步玩家的翅膀状态到客户端，但客户端 `FlightDefault.tick` 方法会在本地检测到“没有翅膀药水效果”时，直接把 `flightApparatus` 重置为 `NONE`。由于远程玩家在本地一般没有该效果，导致刚同步下来的翅膀状态立刻被覆盖，远程玩家始终看不到翅膀。

## 关键改动

1. **只在服务端清除翅膀**
   
   ```java
   // 原逻辑
   if (hasEffect || !player.isEffectiveAi()) {
       if (!hasEffect) {
           this.setWing(FlightApparatus.NONE, PlayerSet.ofAll());
       }
       this.onWornUpdate(player);
   } else if (!player.level().isClientSide) {
       ...
   }
   
   // 修复后
   if (hasEffect || !player.isEffectiveAi()) {
       // 只有服务端才清空翅膀
       if (!hasEffect && !player.level().isClientSide) {
           this.setWing(FlightApparatus.NONE, PlayerSet.ofAll());
       }
       this.onWornUpdate(player);
   } else if (!player.level().isClientSide) {
       ...
   }
   ```

2. **同步后刷新客户端视图**
   
   在 `MessageSyncFlight.handle` 里：
   ```java
   context.enqueueWork(() -> {
       ...
       flight.clone(message.flight());
       WingsMod.instance().invalidateFlightView(player);
   });
   ```
   
   这样客户端收到同步包后会刷新 `FlightView`，渲染层能正确显示远程玩家的翅膀。

## 适用范围

此问题在所有依赖 `FlightDefault.tick` 并有同步逻辑的版本中都可能出现，建议所有分支都采用类似修复方案。
移除@OnlyIn(Dist.CLIENT)，直接删就行



# Sodium / Embeddium 渲染兼容修复指南

本指南记录了 LV Wings 在安装 Embeddium（Sodium Forge 移植版）时翅膀模型渲染消失/塌陷的根本原因与解决方案，方便后续移植或排错。

## 问题现象

- 打开 Embeddium 后，装备模组翅膀的玩家模型身后不再显示 3D 贴图面片。
- 控制台无报错，但翅膀会在切换视角或刷新后持续缺失。

## 根本原因

Embeddium/Sodium 为了提升性能，会在 `ModelPart` 渲染阶段尝试将传入的 `VertexConsumer` 转换为其自定义的 `VertexBufferWriter`。

- 一旦转换成功，Sodium 会跳过原版 `ModelPart.Cube#compile` 的顶点写入逻辑，使用初始化时捕获的静态顶点快照。
- LV Wings 的 `Model3DTexture` 会在构造完成后通过反射重写 `ModelPart.Cube` 的 `polygons`，以实现自定义 3D 面片。Sodium 的快照因此与真实顶点数据不一致，导致渲染结果缺失或畸形。

## 解决方案概览

1. **引入 VertexConsumer 代理**
   - 新增 `renderer.client.cc.lvjia.wings.SodiumBypassVertexConsumer`，对所有 `VertexConsumer` 方法进行透明代理，但**不实现** `VertexBufferWriter` 接口。
   - 当 Sodium 检测到代理对象不满足接口时，会自动回退到原版的顶点写入路径。

2. **在渲染入口统一包裹**
   - `LayerWings.render` 中获取渲染缓冲后立即调用 `SodiumBypassVertexConsumer.wrap(buffer.getBuffer(renderType))`。
   - 确保整个翅膀渲染流程都使用无法被 Sodium 接管的 `VertexConsumer`。

3. **保留模型内的安全包裹**
   - `Model3DTexture.compile` 继续对传入的 `VertexConsumer` 进行二次包裹，保证其他地方直接调用该模型时也能获得兼容性（双重保障，零副作用）。

4. **移除旧的 Embeddium Hook 方案**
   - 删除 `com.toni.wings.compat.embeddium` 目录及相关 mixin 配置，避免残留的线程局部 bypass 代码造成混淆。

## 关键代码片段

```java
// LayerWings.java
VertexConsumer builder = SodiumBypassVertexConsumer.wrap(buffer.getBuffer(form.getRenderType()));
```

```java
// Model3DTexture.java
@Override
public void compile(PoseStack.Pose pose, VertexConsumer buffer, ... ) {
    super.compile(pose, SodiumBypassVertexConsumer.wrap(buffer), ...);
}
```

## 切换维度后重新构建飞行视图

在 `ClientEventHandler` 中添加以下代码，以在玩家切换维度时失效飞行视图缓存，确保翅膀动画在进入末地传送门后仍能正常播放：
```java
private static ResourceKey<Level> lastPlayerDimension;

@SubscribeEvent
public static void onClientTick(ClientTickEvent.Post event) {
    LocalPlayer player = Minecraft.getInstance().player;
    if (player == null) {
        lastPlayerDimension = null;
        return;
    }
    ResourceKey<Level> current = player.level().dimension();
    if (current != lastPlayerDimension) {
        lastPlayerDimension = current;
        FlightViews.invalidate(player);
    }
}
```